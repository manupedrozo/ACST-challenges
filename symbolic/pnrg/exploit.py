import claripy

STATE_VECTOR_LENGTH = 624
STATE_VECTOR_M = 397

UPPER_MASK = 0x80000000
LOWER_MASK = 0x7fffffff

class MTRand:
    def __init__(self):
        self.mt = [0] * 624
        self.index = 0

# mag operation used in the random number generator as in the code inspected in ghidra
def mag(value):
    mag_array = [0x0, 0x9908b0df]
    return claripy.If(value == 0, claripy.BVV(mag_array[0], 64), claripy.BVV(mag_array[1],64))


# testing: non-symbolic mag operation used in the random number generator as in the code inspected in ghidra
def mag_non_sym(value):
    mag_array = [0x0, 0x9908b0df]
    return mag_array[value]


# testing: operate on seed just like code inspected in ghidra (non-symbolic)
def m_seedRand(rand: MTRand, seed: int):
    rand.mt[0] = seed & 0xffffffff
    rand.index = 1

    while rand.index < STATE_VECTOR_LENGTH:
        rand.mt[rand.index] = (6069 * rand.mt[rand.index-1]) & 0xffffffff
        rand.index += 1

# testing: non-symbolic random number generator as in the code inspected in ghidra
def getRandLong_non_sym(rand: MTRand):
    if rand.index < 0 or rand.index >= STATE_VECTOR_LENGTH:
        if rand.index < 0 or rand.index >= STATE_VECTOR_LENGTH + 1:
            m_seedRand(rand, 0x1105)

        kk = 0

        while kk < STATE_VECTOR_LENGTH-STATE_VECTOR_M:
            y = rand.mt[kk + 1] & 0xffffffff
            rand.mt[kk] = rand.mt[kk + STATE_VECTOR_M] ^ (y & LOWER_MASK | (rand.mt[kk] & 0xffffffff) & UPPER_MASK) >> 1 ^ mag_non_sym(y & 1)
            kk = kk + 1

        while kk < STATE_VECTOR_LENGTH - 1:
            y = rand.mt[kk + 1] & 0xffffffff
            rand.mt[kk] = rand.mt[kk + (STATE_VECTOR_M-STATE_VECTOR_LENGTH)] ^ (y & LOWER_MASK | (rand.mt[kk] & 0xffffffff) & UPPER_MASK) >> 1 ^ mag_non_sym(y & 1)
            kk = kk + 1

        y = rand.mt[0] & 0xffffffff
        rand.mt[STATE_VECTOR_LENGTH - 1] = rand.mt[STATE_VECTOR_M - 1] ^ (y & LOWER_MASK | (rand.mt[STATE_VECTOR_LENGTH - 1] & 0xffffffff) & UPPER_MASK) >> 1 ^ mag_non_sym(y & 1)
        rand.index = 0

    iVar1 = rand.index
    rand.index = iVar1 + 1
    uVar2 = rand.mt[iVar1] ^ rand.mt[iVar1] >> 0xb
    uVar2 ^= ((uVar2 << 7) & 0xffffffff) & 0x9d2c5680
    uVar2 ^= ((uVar2 << 0xf) & 0xffffffff) & 0xefc60000
    return uVar2 ^ uVar2 >> 0x12


# random number generator as in the code inspected in ghidra, everything is wrapped in a claripy symbolic value
def genRandLong(rand: MTRand):
    if rand.index < 0 or rand.index >= STATE_VECTOR_LENGTH:
        if rand.index < 0 or rand.index >= STATE_VECTOR_LENGTH + 1:
            m_seedRand(rand, 0x1105)

        kk = 0

        while kk < STATE_VECTOR_LENGTH-STATE_VECTOR_M:
            y = rand.mt[kk + 1] & 0xffffffff
            rand.mt[kk] = rand.mt[kk + STATE_VECTOR_M] ^ claripy.LShR((y & LOWER_MASK | (rand.mt[kk] & 0xffffffff) & UPPER_MASK), 1) ^ mag(y & 1)
            kk = kk + 1

        while kk < STATE_VECTOR_LENGTH - 1:
            y = rand.mt[kk + 1] & 0xffffffff
            rand.mt[kk] = rand.mt[kk + (STATE_VECTOR_M-STATE_VECTOR_LENGTH)] ^ claripy.LShR((y & LOWER_MASK | (rand.mt[kk] & 0xffffffff) & UPPER_MASK), 1) ^ mag(y & 1)
            kk = kk + 1

        y = rand.mt[0] & 0xffffffff
        rand.mt[STATE_VECTOR_LENGTH - 1] = rand.mt[STATE_VECTOR_M - 1] ^ claripy.LShR(y & LOWER_MASK | (rand.mt[STATE_VECTOR_LENGTH - 1] & 0xffffffff) & UPPER_MASK, 1) ^ mag(y & 1)
        rand.index = 0

    iVar1 = rand.index
    rand.index = iVar1 + 1
    uVar2 = rand.mt[iVar1] ^ claripy.LShR(rand.mt[iVar1], 0xb)
    uVar2 ^= ((uVar2 << 7) & 0xffffffff) & 0x9d2c5680
    uVar2 ^= ((uVar2 << 0xf) & 0xffffffff) & 0xefc60000
    return uVar2 ^ claripy.LShR(uVar2, 0x12)


def sym_solve():
    seed = claripy.BVS("seed", 64)
    rand = MTRand()
    m_seedRand(rand, seed)
    for _ in range(1000):
        genRandLong(rand)

    leak_sym = genRandLong(rand)
    s = claripy.Solver()

    leak = int(input("Enter seed:"), base=16)

    s.add(leak_sym == leak) # Add seed constraint

    print(hex(s.eval(seed, 1)[0]))

# for testing: without claripy, calculate the random number from the seed
def non_sym_run():
    seed = int(input("Enter seed:"), base=16)
    rand = MTRand()
    m_seedRand(rand, seed)
    for _ in range(1000):
        getRandLong_non_sym(rand)

    num = getRandLong_non_sym(rand)

    print(f"rng: {hex(num)}")


#non_sym_run()
sym_solve()

